#include <iostream>
#include <string>
#include <vector>
#include <numeric>
#include <algorithm>
#define REP(i, n) for (int i = 0; (i) < (int)(n); ++ (i))
#define REP3(i, m, n) for (int i = (m); (i) < (int)(n); ++ (i))
#define REP_R(i, n) for (int i = (int)(n) - 1; (i) >= 0; -- (i))
#define REP3R(i, m, n) for (int i = (int)(n) - 1; (i) >= (int)(m); -- (i))
#define ALL(x) ::std::begin(x), ::std::end(x)
using namespace std;


int64_t solve(int N, int64_t D, int64_t P, std::vector<int64_t> &F) {
    int64_t sum_normal_trip = std::accumulate(F.begin(), F.end(), 0);
    int64_t sum_discounted_trip = 1000000000000000000;
    int64_t one_ticket = P/D;
    std::sort(F.begin(), F.end(), std::greater<int64_t>());
    int64_t ex_count;
    ex_count = std::count_if(F.begin(), F.end(), [one_ticket](int64_t number) {
        return number > one_ticket;
    });


    while(ex_count > 0){
        if(ex_count >= D){
            F.erase(F.begin(), F.begin() + D);
            F.push_back(P); 
        }
        else{
            if(std::accumulate(F.begin(), F.begin() + ex_count, 0) > P){
                F.erase(F.begin(), F.begin() + ex_count);
                F.push_back(P);
            }
        }
        ex_count -=D;
    }

    sum_discounted_trip = std::accumulate(F.begin(), F.end(), 0);
    return min(sum_discounted_trip, sum_normal_trip);
}

// generated by oj-template v4.8.1 (https://github.com/online-judge-tools/template-generator)
int main() {
    std::ios::sync_with_stdio(false);
    std::cin.tie(nullptr);
    int N;
    int64_t D, P;
    std::cin >> N;
    std::vector<int64_t> F(N);
    std::cin >> D >> P;
    REP (i, N) {
        std::cin >> F[i];
    }
    auto ans = solve(N, D, P, F);
    std::cout << ans << '\n';
    return 0;
}
